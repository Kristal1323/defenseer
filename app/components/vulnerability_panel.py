import streamlit as st
from backend.analyzer import run_bandit_on_file
from backend.classifier import predict_with_confidence
from backend.project_manager import get_full_path


def vuln_badge(label: str, conf: float):
    """Return UI-friendly badge for ML classification."""
    if label == "real":
        return f"ðŸ›‘ **Real Issue** â€” ({conf:.1f}%)"
    return f"âšª **Likely False Positive** â€” ({conf:.1f}%)"


def vulnerability_panel(project_state, pasted_code: str):
    # Friendly overrides for common Bandit rule IDs.
    rule_labels = {
        "B403": "Uses insecure pickle modules",
        "B311": "Uses insecure random generator",
        "B608": "Possible SQL injection via string formatting",
        "B105": "Hardcoded password string",
        "B324": "Weak hash algorithm (MD5/SHA1)",
        "B605": "Shell execution with user input (os.system)",
        "B301": "Insecure deserialization (pickle.loads)",
        "B501": "Unsafe requests call without verification",
        "B303": "Weak crypto cipher or mode",
        "B306": "Base64/hex decode of untrusted input",
        "B317": "Unsafe XML parsing",
        "B602": "Subprocess call with shell=True",
    }

    # Determine active file path
    file_path = None
    project_name = project_state.get("project_name")
    active_file = project_state.get("active_file")

    if project_name and active_file:
        file_path = get_full_path(project_name, active_file)

    has_pasted_code = bool(pasted_code and pasted_code.strip())

    if not file_path and not has_pasted_code:
        st.info("Upload a file or paste code to begin analysis.")
        return

    # -------------------------
    # Run Scan
    # -------------------------
    if st.button("Run Security Scan", type="primary"):
        with st.spinner("Analyzing vulnerabilities..."):

            try:
                if file_path:
                    issues = run_bandit_on_file(file_path)
                else:
                    tmp_path = "tmp_pasted_code.py"
                    with open(tmp_path, "w") as f:
                        f.write(pasted_code)
                    issues = run_bandit_on_file(tmp_path)
            except Exception as e:
                st.error(f"Failed to analyze code: {e}")
                return

        if not issues:
            st.success("ðŸŽ‰ No vulnerabilities detected!")
            return

        # Save to session for downstream features (AI fixes, etc.)
        st.session_state["scan_results"] = issues

        st.write(f"### ðŸ§© Found {len(issues)} potential issues")

        for issue in issues:
            rule_id = issue.get("test_id", "N/A")
            msg = issue.get("issue_text", "No description")
            friendly_label = rule_labels.get(rule_id, msg)
            line = issue.get("line_number", "?")
            severity = issue.get("issue_severity", "?")
            code_snippet = issue.get("code", "").strip()

            # ML prediction
            label, conf = predict_with_confidence(msg)

            st.markdown("---")
            st.markdown(f"### {vuln_badge(label, conf)}")

            # Metadata columns
            cols = st.columns(2)
            with cols[0]:
                st.markdown(f"**Rule:** `{rule_id}`")
                st.markdown(f"**Label:** {friendly_label}")
                st.markdown(f"**Severity:** `{severity}`")
                st.markdown(f"**Line:** `{line}`")

            with cols[1]:
                st.markdown("**ML Classification:**")
                if label == "real":
                    st.markdown(
                        "<span style='color:#ff4d4f; font-weight:600;'>Real Issue</span>",
                        unsafe_allow_html=True,
                    )
                else:
                    st.markdown(
                        "<span style='color:#888; font-weight:600;'>False Positive</span>",
                        unsafe_allow_html=True,
                    )
                st.markdown(f"**Confidence:** {conf:.1f}%")

            # Code snippet
            if code_snippet:
                st.markdown("**Code Snippet:**")
                st.code(code_snippet, language="python")
