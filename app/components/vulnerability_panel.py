import streamlit as st
from backend.analyzer import run_bandit_on_file
from backend.classifier import predict_with_confidence
from backend.project_manager import get_full_path


def vuln_badge(label: str, conf: float):
    """Return UI-friendly badge for ML classification."""
    if label == "real":
        return f"ðŸ›‘ **Real Issue** â€” ({conf:.1f}%)"
    return f"âšª **Likely False Positive** â€” ({conf:.1f}%)"


def vulnerability_panel(project_state, pasted_code: str):
    # Friendly overrides for common Bandit rule IDs.
    rule_labels = {
        "B403": "Uses insecure pickle modules",
        "B311": "Uses insecure random generator",
        "B608": "Possible SQL injection via string formatting",
        "B105": "Hardcoded password string",
        "B324": "Weak hash algorithm (MD5/SHA1)",
        "B605": "Shell execution with user input (os.system)",
        "B301": "Insecure deserialization (pickle.loads)",
        "B501": "Unsafe requests call without verification",
        "B303": "Weak crypto cipher or mode",
        "B306": "Base64/hex decode of untrusted input",
        "B317": "Unsafe XML parsing",
        "B602": "Subprocess call with shell=True",
    }

    # Determine active file path
    file_path = None
    project_name = project_state.get("project_name")
    active_file = project_state.get("active_file")

    if project_name and active_file:
        file_path = get_full_path(project_name, active_file)

    has_pasted_code = bool(pasted_code and pasted_code.strip())

    if not file_path and not has_pasted_code:
        st.info("Upload a file or paste code to begin analysis.")
        return

    # -------------------------
    # Run Scan
    # -------------------------
    if st.button("â–¶ Run Security Scan", type="primary"):
        with st.spinner("Analyzing vulnerabilities..."):

            try:
                if file_path:
                    issues = run_bandit_on_file(file_path)
                else:
                    tmp_path = "tmp_pasted_code.py"
                    with open(tmp_path, "w") as f:
                        f.write(pasted_code)
                    issues = run_bandit_on_file(tmp_path)
            except Exception as e:
                st.error(f"Failed to analyze code: {e}")
                return

        if not issues:
            st.success("ðŸŽ‰ No vulnerabilities detected!")
            return

        # Save to session for downstream features (AI fixes, etc.)
        st.session_state["scan_results"] = issues

        st.write(f"### ðŸ§© Found {len(issues)} potential issues")

    issues = st.session_state.get("scan_results")
    if not issues:
        return

    # -------------------------
    # Filters & sorting
    # -------------------------
    st.divider()
    st.markdown("**Filter & Sort**")

    severities = {"HIGH", "MEDIUM", "LOW"}
    selected_sev = st.multiselect(
        "Severity",
        options=["HIGH", "MEDIUM", "LOW"],
        default=["HIGH", "MEDIUM", "LOW"],
    )

    label_filter = st.selectbox(
        "ML label",
        options=["Any", "Real issues only", "False positives only"],
        index=0,
    )

    rule_filter = st.text_input("Rule contains", value="")

    sort_by = st.selectbox(
        "Sort by",
        options=["severity", "line_number", "rule_id", "model_confidence"],
        index=0,
    )

    def sort_key(issue):
        sev_order = {"HIGH": 0, "MEDIUM": 1, "LOW": 2}
        if sort_by == "severity":
            return sev_order.get(issue.get("issue_severity"), 3)
        if sort_by == "line_number":
            return issue.get("line_number") or 0
        if sort_by == "rule_id":
            return issue.get("test_id") or ""
        if sort_by == "model_confidence":
            return issue.get("model_confidence", 0) * -1
        return 0

    def passes_filters(issue):
        if issue.get("issue_severity") not in selected_sev:
            return False
        if rule_filter and rule_filter.lower() not in (issue.get("test_id", "") + issue.get("test_name", "")).lower():
            return False
        lbl = issue.get("ml_label", "real")
        if label_filter == "Real issues only" and lbl != "real":
            return False
        if label_filter == "False positives only" and lbl != "false_positive":
            return False
        return True

    filtered = [i for i in issues if passes_filters(i)]
    filtered.sort(key=sort_key)

    st.write(f"### ðŸ§© Showing {len(filtered)} issues (of {len(issues)})")

    for issue in filtered:
        rule_id = issue.get("test_id", "N/A")
        msg = issue.get("issue_text", "No description")
        friendly_label = rule_labels.get(rule_id, msg)
        line = issue.get("line_number", "?")
        severity = issue.get("issue_severity", "?")
        code_snippet = issue.get("code", "").strip()
        label = issue.get("ml_label", "real")
        conf = issue.get("model_confidence", 0.0)

        # Backfill ML if not present
        if "ml_label" not in issue or "model_confidence" not in issue:
            label, conf = predict_with_confidence(msg)
            issue["ml_label"] = label
            issue["model_confidence"] = conf

        st.markdown("---")
        st.markdown(f"### {vuln_badge(label, conf)}")

        # Metadata columns
        cols = st.columns(2)
        with cols[0]:
            st.markdown(f"**Rule:** `{rule_id}`")
            st.markdown(f"**Label:** {friendly_label}")
            st.markdown(f"**Severity:** `{severity}`")
            st.markdown(f"**Line:** `{line}`")

        with cols[1]:
            st.markdown("**ML Classification:**")
            if label == "real":
                st.markdown(
                    "<span style='color:#ff4d4f; font-weight:600;'>Real Issue</span>",
                    unsafe_allow_html=True,
                )
            else:
                st.markdown(
                    "<span style='color:#888; font-weight:600;'>False Positive</span>",
                    unsafe_allow_html=True,
                )
            st.markdown(f"**Confidence:** {conf:.1f}%")

        # Code snippet
        if code_snippet:
            st.markdown("**Code Snippet:**")
            st.code(code_snippet, language="python")
